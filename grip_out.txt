
// dir\try.go
package main


// main.go
package main

import (
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
)

func main() {
	// Parse flags
	// match := flag.String("match", "*", "Blob pattern to match files")
	// out := flag.String("out", "output.txt", "Output file")
	// headFile := flag.String("head-file", "", "File containing header content")
	// head := flag.String("head", "", "Inline header content")
	// flag.Parse()

	dir := os.Args[1]

	match := flag.String("match", "*", "Glob pattern to match files")
	out := flag.String("out", "./grip_out.txt", "Path to output file")
	headFile := flag.String("head-file", "", "Path to file containing prompt to add to start of output (optional)")
	head := flag.String("head", "", "Prompt to add to the start of output (optional)")

	flag.CommandLine.Parse(os.Args[2:])

	// Ensure a directory argument is provided
	if dir == "" {
		fmt.Println("You must specify a directory.")
		os.Exit(1)
	}

	// Ensure --head and --head-file are not both set
	if *head != "" && *headFile != "" {
		fmt.Println("You cannot specify both --head and --head-file.")
		os.Exit(1)
	}

	// Read header content
	var headerContent string
	if *head != "" {
		headerContent = *head
	} else if *headFile != "" {
		data, err := ioutil.ReadFile(*headFile)
		if err != nil {
			fmt.Println("Error reading head file:", err)
			os.Exit(1)
		}
		headerContent = string(data)
	}
	print(*match)

	// Collect contents
	var contents []string
	err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if !info.IsDir() && matchFile(path, *match) {
			data, err := ioutil.ReadFile(path)
			if err != nil {
				return err
			}
			relativePath, err := filepath.Rel(dir, path)
			if err != nil {
				return err
			}
			contents = append(contents, "// "+relativePath+"\n"+string(data))
		}
		return nil
	})
	if err != nil {
		fmt.Println("Error walking the directory:", err)
		os.Exit(1)
	}

	// Write to output file
	err = ioutil.WriteFile(*out, []byte(headerContent+"\n"+strings.Join(contents, "\n\n")), 0644)
	if err != nil {
		fmt.Println("Error writing to output file:", err)
		os.Exit(1)
	}
}

// matchFile checks if the file matches the given pattern
func matchFile(path, pattern string) bool {
	matched, err := filepath.Match(pattern, filepath.Base(path))
	if err != nil {
		return false
	}
	return matched
}


// main_test.go
// package main

// import (
// 	"io/ioutil"
// 	"os"
// 	"os/exec"
// 	"path/filepath"
// 	"strings"
// 	"testing"
// )

// func TestMain(t *testing.T) {
// 	// Create test directory and files
// 	testDir := "test_dir"
// 	os.Mkdir(testDir, 0755)
// 	defer os.RemoveAll(testDir)

// 	libDir := filepath.Join(testDir, "lib")
// 	os.Mkdir(libDir, 0755)

// 	file1 := filepath.Join(libDir, "front.go")
// 	file2 := filepath.Join(libDir, "back.go")
// 	ioutil.WriteFile(file1, []byte("package lib\n\nfunc Front() {\n    // front function\n}"), 0644)
// 	ioutil.WriteFile(file2, []byte("package lib\n\nfunc Back() {\n    // back function\n}"), 0644)

// 	headFile := "head.txt"
// 	ioutil.WriteFile(headFile, []byte("Header content"), 0644)
// 	defer os.Remove(headFile)

// 	// Test cases
// 	tests := []struct {
// 		args        []string
// 		expected    string
// 		shouldError bool
// 	}{
// 		{
// 			args:        []string{testDir, "--out=out.txt"},
// 			expected:    "// lib/front.go\npackage lib\n\nfunc Front() {\n    // front function\n}\n\n// lib/back.go\npackage lib\n\nfunc Back() {\n    // back function\n}\n",
// 			shouldError: false,
// 		},
// 		{
// 			args:        []string{testDir, "--out=out.txt", "--match=lib/*.go"},
// 			expected:    "// lib/front.go\npackage lib\n\nfunc Front() {\n    // front function\n}\n\n// lib/back.go\npackage lib\n\nfunc Back() {\n    // back function\n}\n",
// 			shouldError: false,
// 		},
// 		{
// 			args:        []string{testDir, "--out=out.txt", "--head=Inline header"},
// 			expected:    "Inline header\n\n// lib/front.go\npackage lib\n\nfunc Front() {\n    // front function\n}\n\n// lib/back.go\npackage lib\n\nfunc Back() {\n    // back function\n}\n",
// 			shouldError: false,
// 		},
// 		{
// 			args:        []string{testDir, "--out=out.txt", "--head-file=" + headFile},
// 			expected:    "Header content\n\n// lib/front.go\npackage lib\n\nfunc Front() {\n    // front function\n}\n\n// lib/back.go\npackage lib\n\nfunc Back() {\n    // back function\n}\n",
// 			shouldError: false,
// 		},
// 		{
// 			args:        []string{testDir, "--out=out.txt", "--head=Inline header", "--head-file=" + headFile},
// 			expected:    "",
// 			shouldError: true,
// 		},
// 	}

// 	for _, test := range tests {
// 		cmd := exec.Command("go", "run", ".", test.args...)
// 		output, err := cmd.CombinedOutput()
// 		if test.shouldError {
// 			if err == nil {
// 				t.Fatalf("expected an error but got none, output: %s", output)
// 			}
// 		} else {
// 			if err != nil {
// 				t.Fatalf("unexpected error: %v, output: %s", err, output)
// 			}
// 			content, err := ioutil.ReadFile("out.txt")
// 			if err != nil {
// 				t.Fatalf("error reading output file: %v", err)
// 			}
// 			if strings.TrimSpace(string(content)) != strings.TrimSpace(test.expected) {
// 				t.Fatalf("expected %q but got %q", test.expected, string(content))
// 			}
// 		}
// 	}
// }
